/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 11.0.8
*/
const t="iec",i="jedec",e="bits",o="byte",n="bytes",r="array",l="object",s="string",a="exponent",b="round",p="",u={symbol:{iec:{bits:["bit","Kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],bytes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"]},jedec:{bits:["bit","Kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],bytes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]}},fullform:{iec:["","kibi","mebi","gibi","tebi","pebi","exbi","zebi","yobi"],jedec:["","kilo","mega","giga","tera","peta","exa","zetta","yotta"]}},c=[1,1024,1048576,1073741824,1099511627776,0x4000000000000,0x1000000000000000,11805916207174113e5,12089258196146292e8],f=[1,1e3,1e6,1e9,1e12,1e15,1e18,1e21,1e24],d=Math.log(1024),m=Math.log(1e3);function g(g,{bits:y=!1,pad:B=!1,base:h=-1,round:M=2,locale:x="",localeOptions:E={},separator:P="",spacer:j=" ",symbols:T={},standard:w="",output:N=s,fullform:$=!1,fullforms:k=[],exponent:v=-1,roundingMethod:G=b,precision:K=0}={}){let S,Y,Z,O=v,z=Number(g),I=[],L=0,D=p;"si"===w?(S=!0,Y=1e3,Z=i):w===t?(S=!1,Y=1024,Z=t):w===i?(S=!1,Y=1024,Z=i):2===h?(S=!1,Y=1024,Z=t):(S=!0,Y=1e3,Z=i);const q=!0===$,A=z<0,C=Math[G];if("bigint"!=typeof g&&isNaN(g))throw new TypeError("Invalid number");if("function"!=typeof C)throw new TypeError("Invalid rounding method");if(A&&(z=-z),0===z)return I[0]=K>0?(0).toPrecision(K):0,D=I[1]=u.symbol[Z][y?e:n][0],N===a?0:(T[I[1]]&&(I[1]=T[I[1]]),q&&(I[1]=k[0]||u.fullform[Z][0]+(y?"bit":o)),N===r?I:N===l?{value:I[0],symbol:I[1],exponent:0,unit:D}:I.join(j));if((-1===O||isNaN(O))&&(O=S?Math.floor(Math.log(z)/m):Math.floor(Math.log(z)/d),O<0&&(O=0)),O>8&&(K>0&&(K+=8-O),O=8),N===a)return O;let F;F=S?f[O]:c[O],L=z/F,y&&(L*=8,L>=Y&&O<8&&(L/=Y,O++));const H=O>0&&M>0?Math.pow(10,M):1;I[0]=1===H?C(L):C(L*H)/H,I[0]===Y&&O<8&&-1===v&&(I[0]=1,O++),K>0&&(I[0]=I[0].toPrecision(K),I[0].includes("e")&&O<8&&(O++,F=S?f[O]:c[O],L=z/F,I[0]=(1===H?C(L):C(L*H)/H).toPrecision(K)));const J=u.symbol[Z][y?e:n];if(D=I[1]=S&&1===O?y?"kbit":"kB":J[O],A&&(I[0]=-I[0]),T[I[1]]&&(I[1]=T[I[1]]),!0===x?I[0]=I[0].toLocaleString():x.length>0?I[0]=I[0].toLocaleString(x,E):P.length>0&&(I[0]=I[0].toString().replace(".",P)),B&&M>0){const t=I[0].toString(),i=P||(t.match(/(\D)/g)||[]).pop()||".",e=t.split(i),o=e[1]||p,n=o.length,r=M-n;I[0]=`${e[0]}${i}${o.padEnd(n+r,"0")}`}return q&&(I[1]=k[O]||u.fullform[Z][O]+(y?"bit":o)+(1===I[0]?p:"s")),N===r?I:N===l?{value:I[0],symbol:I[1],exponent:O,unit:D}:" "===j?`${I[0]} ${I[1]}`:I.join(j)}function y({bits:t=!1,pad:i=!1,base:e=-1,round:o=2,locale:n="",localeOptions:r={},separator:l="",spacer:a=" ",symbols:p={},standard:u="",output:c=s,fullform:f=!1,fullforms:d=[],exponent:m=-1,roundingMethod:y=b,precision:B=0}={}){return s=>g(s,{bits:t,pad:i,base:e,round:o,locale:n,localeOptions:r,separator:l,spacer:a,symbols:p,standard:u,output:c,fullform:f,fullforms:d,exponent:m,roundingMethod:y,precision:B})}export{g as filesize,y as partial};//# sourceMappingURL=filesize.min.js.map
