/*!
 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 @version 11.0.8
*/
const t="iec",e="jedec",i="bits",o="byte",n="bytes",r="array",l="object",a="string",s="exponent",b="round",p="",u={symbol:{iec:{bits:["bit","Kibit","Mibit","Gibit","Tibit","Pibit","Eibit","Zibit","Yibit"],bytes:["B","KiB","MiB","GiB","TiB","PiB","EiB","ZiB","YiB"]},jedec:{bits:["bit","Kbit","Mbit","Gbit","Tbit","Pbit","Ebit","Zbit","Ybit"],bytes:["B","KB","MB","GB","TB","PB","EB","ZB","YB"]}},fullform:{iec:["","kibi","mebi","gibi","tebi","pebi","exbi","zebi","yobi"],jedec:["","kilo","mega","giga","tera","peta","exa","zetta","yotta"]}},c=[1,1024,1048576,1073741824,1099511627776,0x4000000000000,0x1000000000000000,11805916207174113e5,12089258196146292e8],f=[1,1e3,1e6,1e9,1e12,1e15,1e18,1e21,1e24],d=Math.log(1024),g=Math.log(1e3);function h(h,{bits:m=!1,pad:y=!1,base:B=-1,round:M=2,locale:x="",localeOptions:w={},separator:E="",spacer:P=" ",symbols:j={},standard:T="",output:N=a,fullform:$=!1,fullforms:k=[],exponent:v=-1,roundingMethod:G=b,precision:K=0}={}){let S,Y,Z,O=v,z=Number(h),I=[],L=0,D=p;"si"===T?(S=!0,Y=1e3,Z=e):T===t?(S=!1,Y=1024,Z=t):T===e?(S=!1,Y=1024,Z=e):2===B?(S=!1,Y=1024,Z=t):(S=!0,Y=1e3,Z=e);const q=!0===$,A=z<0,C=Math[G];if("bigint"!=typeof h&&isNaN(h))throw new TypeError("Invalid number");if("function"!=typeof C)throw new TypeError("Invalid rounding method");if(A&&(z=-z),0===z)return I[0]=K>0?(0).toPrecision(K):0,D=I[1]=u.symbol[Z][m?i:n][0],N===s?0:(j[I[1]]&&(I[1]=j[I[1]]),q&&(I[1]=k[0]||u.fullform[Z][0]+(m?"bit":o)),N===r?I:N===l?{value:I[0],symbol:I[1],exponent:0,unit:D}:I.join(P));if((-1===O||isNaN(O))&&(O=S?Math.floor(Math.log(z)/g):Math.floor(Math.log(z)/d),O<0&&(O=0)),O>8&&(K>0&&(K+=8-O),O=8),N===s)return O;let F;F=S?O<f.length?f[O]:Math.pow(1e3,O):O<c.length?c[O]:Math.pow(2,10*O),L=z/F,m&&(L*=8,L>=Y&&O<8&&(L/=Y,O++));const H=O>0&&M>0?Math.pow(10,M):1;I[0]=1===H?C(L):C(L*H)/H,I[0]===Y&&O<8&&-1===v&&(I[0]=1,O++),K>0&&(I[0]=I[0].toPrecision(K),I[0].includes("e")&&O<8&&(O++,F=S?O<f.length?f[O]:Math.pow(1e3,O):O<c.length?c[O]:Math.pow(2,10*O),L=z/F,I[0]=(1===H?C(L):C(L*H)/H).toPrecision(K)));const J=u.symbol[Z][m?i:n];if(D=I[1]=S&&1===O?m?"kbit":"kB":J[O],A&&(I[0]=-I[0]),j[I[1]]&&(I[1]=j[I[1]]),!0===x?I[0]=I[0].toLocaleString():x.length>0?I[0]=I[0].toLocaleString(x,w):E.length>0&&(I[0]=I[0].toString().replace(".",E)),y&&M>0){const t=I[0].toString(),e=E||(t.match(/(\D)/g)||[]).pop()||".",i=t.split(e),o=i[1]||p,n=o.length,r=M-n;I[0]=`${i[0]}${e}${o.padEnd(n+r,"0")}`}return q&&(I[1]=k[O]||u.fullform[Z][O]+(m?"bit":o)+(1===I[0]?p:"s")),N===r?I:N===l?{value:I[0],symbol:I[1],exponent:O,unit:D}:" "===P?`${I[0]} ${I[1]}`:I.join(P)}function m({bits:t=!1,pad:e=!1,base:i=-1,round:o=2,locale:n="",localeOptions:r={},separator:l="",spacer:s=" ",symbols:p={},standard:u="",output:c=a,fullform:f=!1,fullforms:d=[],exponent:g=-1,roundingMethod:m=b,precision:y=0}={}){return a=>h(a,{bits:t,pad:e,base:i,round:o,locale:n,localeOptions:r,separator:l,spacer:s,symbols:p,standard:u,output:c,fullform:f,fullforms:d,exponent:g,roundingMethod:m,precision:y})}export{h as filesize,m as partial};//# sourceMappingURL=filesize.min.js.map
